# 基本概念的普及

## 高内聚 低耦合

高内聚低耦合，是软件工程中的概念，是判断软件设计好坏的标准，主要用于程序的面向对象的设计，主要看类的内聚性是否高，耦合度是否低。目的是使程序模块的可重用性、移植性大大增强。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。

前言
高内聚低耦合，是软件工程中的概念，是判断设计好坏的标准，主要是面向对象的设计，看类的内聚性是否高，耦合度是否低。

概念
内聚关注模块内部的元素结合程度，耦合关注模块之间的依赖程度。

内聚性：
又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。

所谓高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。

耦合性：
也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。

对于低耦合，粗浅的理解是：一个完整的系统，模块与模块之间，尽可能的使其独立存在。也就是说，让每个模块，尽可能的独立完成某个特定的子功能。模块与模块之间的接口，尽量的少而简单。如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分。这样有利于修改和组合。

内聚
内聚有如下的种类，它们之间的内聚度由弱到强排列如下：

一、偶然内聚：一个模块内的各处理元素之间没有任何联系，只是偶然地被凑到一起。这种模块也称为巧合内聚，内聚程度最低。

二、逻辑内聚：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能 。

三、时间内聚：把需要同时执行的动作组合在一起形成的模块称为时间内聚模块。

四、过程内聚：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。简单的说就是如果一个模块内的处理元素是相关的，而且必须以特定次序执行则称为过程内聚。

例如某要完成登录的功能，前一个功能判断网络状态，后一个执行登录操作，显然是按照特定次序执行的。

五、通信内聚：指模块内所有处理元素都在同一个数据结构上操作或所有处理功能都通过公用数据而发生关联（有时称之为信息内聚）。即指模块内各个组成部分都使用相同的数据结构或产生相同的数据结构。

六、顺序内聚：一个模块中各个处理元素和同一个功能密切相关，而且这些处理必须顺序执行，通常前一个处理元素的输出时后一个处理元素的输入。

例如某要完成获取订单信息的功能，前一个功能获取用户信息，后一个执行计算均价操作，显然该模块内两部分紧密关联。
顺序内聚的内聚度比较高，但缺点是不如功能内聚易于维护。

七、功能内聚：模块内所有元素的各个组成部分全部都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分。即模块仅包括为完成某个功能所必须的所有成分，这些成分紧密联系、缺一不可。

功能内聚是最强的内聚，其优点是它的功能明确。判断一个模块是否功能内聚，一般从模块名称就能看出。如果模块名称只有一个动词和一个特定的目标（单数名词），一般来说就是功能内聚，如：“计算水费”、“计算产值”等模块。功能内聚一般出现在软件结构图的较低层次上。
功能内聚模块的一个重要特点是：他是一个“暗盒”，对于该模块的调用者来说，只需要知道这个模块能做什么，而不需要知道这个模块是如何做的。

耦合
耦合可以分为以下几种，它们之间的耦合度由高到低排列如下：

一、 内容耦合：一个模块直接访问另一模块的内容，则称这两个模块为内容耦合。
若在程序中出现下列情况之一，则说明两个模块之间发生了内容耦合：
1. 一个模块直接访问另一个模块的内部数据。
2. 一个模块不通过正常入口而直接转入到另一个模块的内部。
3. 两个模块有一部分代码重叠（该部分代码具有一定的独立功能）。
4. 一个模块有多个入口。
内容耦合可能在汇编语言中出现。大多数高级语言都已设计成不允许出现内容耦合。这种耦合的耦合性最强，模块独立性最弱。

二、公共耦合：一组模块都访问同一个全局数据结构，则称之为公共耦合。公共数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。如果模块只是向公共数据环境输入数据，或是只从公共数据环境取出数据，这属于比较松散的公共耦合；如果模块既向公共数据环境输入数据又从公共数据环境取出数据，这属于较紧密的公共耦合。
公共耦合会引起以下问题：
1. 无法控制各个模块对公共数据的存取，严重影响了软件模块的可靠性和适应性。
2. 使软件的可维护性变差。若一个模块修改了公共数据，则会影响相关模块。
3. 降低了软件的可理解性。不容易清楚知道哪些数据被哪些模块所共享，排错困难。
一般地，仅当模块间共享的数据很多且通过参数传递很不方便时，才使用公共耦合。

三、外部耦合：一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。

四、控制耦合：模块之间传递的不是数据信息，而是控制信息例如标志、开关量等，一个模块控制了另一个模块的功能。

五、标记耦合：调用模块和被调用模块之间传递数据结构而不是简单数据，同时也称作特征耦合。表就和的模块间传递的不是简单变量，而是像高级语言中的数据名、记录名和文件名等数据结果，这些名字即为标记，其实传递的是地址。

六、数据耦合：调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的值传递。

七、非直接耦合：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。

分析
高内聚，低耦合的系统有什么好处呢？
事实上，短期来看，并没有很明显的好处，甚至短期内会影响系统的开发进度，因为高内聚，低耦合的系统对开发设计人员提出了更高的要求。高内聚，低耦合的好处体现在系统持续发展的过程中，高内聚，低耦合的系统具有更好的重用性，维护性，扩展性，可以更高效的完成系统的维护开发，持续的支持业务的发展，而不会成为业务发展的障碍。

高内聚低耦合是否意味着内聚越高越好，耦合越低越好？
并不是内聚越高越好，耦合越低越好，真正好的设计是在高内聚和低耦合间进行平衡，也就是说高内聚和低耦合是冲突的。
最强的内聚莫过于一个类只写一个函数，这样内聚性绝对是最高的。但这会带来一个
明显的问题：类的数量急剧增多，这样就导致了其它类的耦合特别多，于是整个设计就变成了“高内聚高耦合”了。由于高耦合，整个系统变动同样非常频繁。
对于耦合来说，最弱的耦合是一个类将所有的函数都包含了，这样类完全不依赖其它类，耦合性是最低的。但这样会带来一个明显的问题：内聚性很低，于是整个设计就变成了“低耦合低内聚”了。由于低内聚，整个类的变动同样非常频繁。
真正做到高内聚、低耦合是很难的，很多时候未必一定要这样，更多的时候“最适合”的才是最好的，不过、审时度势、融会贯通、人尽其才、物尽其用，才是设计的王道。
软件设计时，如何做好高内聚低耦合？
在模块划分时，要遵循“一个模块，一个功能”的原则，尽可能使模块达到功能内聚。
耦合是影响软件复杂程度和设计质量的一个重要因素，为提高模块的独立性，应建立模块间尽可能松散的系统，在设计上我们应采用以下原则：若模块间必须存在耦合，应尽量使用数据耦合，少用控制耦合，慎用或有控制地使用公共耦合，并限制公共耦合的范围，尽量避免内容耦合。


## 函数式编程

面向函数范式编程(Functional programming)
　　函数编程(简称FP)不只代指Haskell Scala等之类的语言，还表示一种编程思维，软件思考方式，也称面向函数编程。 编程的本质是组合，组合的本质是范畴Category，而范畴是函数的组合。

　　首先，什么是函数式编程，这并没有唯一定义，它只是广泛聚合了一些编程风格的特性，我们可以将它与面向对象编程OOP进行对比， 两者区别是，OOP主要聚焦于数据的区别，而FP则注重数据结构的一致性。OOP最大优点是多态性和封装；而FP优势是不变性及其声明性风格，两者其实是正交，可互补的，可在同一程序中共存。

面向对象：

数据和对数据的操作紧紧耦合
.对象隐藏它们操作的实现细节，其他对象调用这些操作只需要通过接口。
.核心抽象模型是数据自己
核心活动是组合新对象和拓展已经存在的对象，这是通过加入新的方法实现的。
函数编程：

数据与函数是松耦合的
函数隐藏了它们的实现，语言的抽象是函数，以及将函数组合起来表达。
核心抽象模型是函数，不是数据结构
核心活动是编写新的函数。
变量缺省是不变的，减少可变性变量的使用，并发性好
　　那么OOP和FP在业务领域是否有胜者呢？ 我们大部分业务逻辑是这样写：


SELECT orders.order_id, orders.order_date, suppliers.supplier_name
　　FROM suppliers
　　RIGHT OUTER JOIN orders
　　ON suppliers.supplier_id = orders.supplier_id
　　WHERE orders.order_status = 'INCOMPLETE'
　　ORDER BY orders.order_date DESC;

　　SQL是非常类似FP，它能渗透到业务中，它使用一致的数据结构(数据表结构Schema)，一些基本函数能组合成很多查询语句，它是declarative声明式的， 也就是说，写出的SQL是告诉数据库我需要什么，数据库就为你返回，而不必指定数据库如何具体去查询。

　　声明式编程和命令式编程区别？ FP的主要特点是它们描述它们要"什么"，而不是如何实现。而OO在其方法中，还是使用大部分命令式技术。 下面是命令式技术代码：

var sumOfSquares = function(list) {
　　var result = 0;
　　for (var i = 0; i < list.length; i++) {
　　　　result += square(list[i]);
　　}
　　return result;
};

console.log(sumOfSquares([2, 3, 5]));

函数编程代码如下：
var sumOfSquares = pipe(map(square), reduce(add, 0));
console.log(sumOfSquares([2, 3, 5]));
　　函数风格的编程特点：

第一等公民是函数
带有闭包的Lambdas/Anonymous函数
不变性，大部分无态处理，没有状态和变量
高并发
无副作用的调用
通过tail call实现递归的性能优化。
模式匹配(Haskell, Erlang)
懒赋值(Miranda, Haskell)
Homoiconicity(类似LISP)
　　如果说OOP还有很多人可能受静态数据思路影响，那么FP 带来完全是动态事件，FP让我们直接用动词思考，用方法函数解决问题，比如两个帐号之间的转帐，按照DDD等静态领域建模思维，转帐这个功能是放在帐号这个实体类中，还是做一个服务呢？在OOP语言中，我们实现功能总是使用服务Service这样一个概念替代，而且强调无态服务，无态服务实际就是一个只有方法函数没有属性的空架子“类”而已。 2007年的Adam Heroku一篇博文中写道：银行账户之间转帐的老式做法是使用数据库事务，这种做法比较刚性，正确做法是将转帐事件存储起来，如果你是一个面向函数范式的思维者觉得这样做就很正常。---来自" NOSQL存储的基于事件的事务实现 " 。

　　有很多人将FP归结于数学思维，实际上这只看到其表面，没有看到数学语言这个背后的形式逻辑，编程语言作为和数学同等形式语言，他们的核心基础都是分析哲学的形式逻辑，过去的面向对象很多设计原则也来源于形式逻辑，见：蒯因与引用透明 。　　

　　面向对象和面向函数一直在争论，实际上纯粹的OOP和纯粹的FP都是极端的，对于OOP来讲：存在的并一定都是对象，函数就不是对象；对于FP来说：存在的并不总是纯粹的，副作用总是真实存在。总之，面向对象侧重于分解，函数编程侧重于组合。

　

文章
类型系统和逻辑
函数式编程模式：单位元(幺元)
函数式编程模式：半群
范畴category:组合的本质
什么是Monoid ?
什么是Monad？
为什么需要Monad? 
面向对象与函数编程的比较
OOP和FP错在哪里？
为什么组合好于继承？ 
什么是流式思维？
Reactive设计语言与范式
蒯因与引用透明
为什么我再也不使用MVC框架了？
微服务的最终一致性与事件流
一张图解说Map/filter/reduce
从CRUD编程切换到事件溯源和区块链编程
一篇有关函数式编程的形象生动教程
Java8
Closure Lambda和Monad
分分钟学会Java8的Lambda
Java 8十个lambda表达式案例
Java8教程
使用Java8的Lambda实现的一个简单案例
使用Java8的Lambda实现Monda
使用Java8的Lambda实现模板模式
使用Java8的Lambda实现策略模式
Java8的Lambda和排序
用Java 8 lambda优化JDBC
使用Java8的Lambda简化ReadWriteLock
Java 8的Lambda表达式的阴暗面
用monad替代嵌套回调
更多Java8专题

 

其他语言
HASKELL入门起步
Scala入门之函数编程
Scala入门之基本概念
更多Scala专题

Javascript闭包是什么？
Scala中文教程和手册
苹果Swift语言中文简明教程
Javascript的函数式编程术语解释
 
参考
Python语言教程手册
Reactive专题
面向函数编程系列专题
EventSourcing  
形式逻辑专题
Node.js专题