# JavaScript执行机制深度解析——EC和Scope、VO、AO（ES3规范）

## 前文回顾

在探讨JavaScript执行机制的时候，我们首先引入了event loop模型，从宏观上对于JavaScript运行机制有个**大概**的了解，然后针对该模型各个部分做了详细的拆分解析，在[《JavaScript执行机制深度解析——调用栈、异步队列和事件循环》](https://github.com/Martin-Shao/Road-to-FullStack/blob/master/javascript/running-analysis/readme.md)中，我们主要探讨的JavaScript作为单线程语言，如何处理异步问题的。

![alt text](../_assets/20190527161927.png "JavaScript call stack ")

在[《JavaScript执行机制深度解析——执行上下文与调用栈》](https://github.com/Martin-Shao/Road-to-FullStack/blob/master/javascript/running-analysis/readme.md)中我们把上图中关于内存分配，执行上下文和调用栈的关系进行讲解，本文则是对于执行上下文更加深入的解析。

我们大致知道执行上下文就是函数运行时的环境，但是这个环境如何具象化，我们还需要引出变量对象的概念，把它看做一个对象，这个对象存储着JavaScript函数运行的一切条件。这样就能更加具体对于变量、函数声明、作用域、作用域链进行更加详尽的阐述。

但在深入讨论之前，我还在[《JavaScript执行机制深度解析——执行上下文ES3规范和ES5规范》](https://github.com/Martin-Shao/Road-to-FullStack/blob/master/javascript/running-analysis/readme.md)一文中，对于讨论执行上下文划分了一个界限，以不同版本的实现标准为依据进行讨论。本文主要探讨的ES3版本的执行上下文实现机制，其中包含的主要内容有变量对象、活动对象、作用域、作用域链、闭包等

## 大纲

* 变量和执行上下文作为知识讲解的铺垫
* 了解执行上下文的组成
* 接触到变量对象（Variable Object）的概念
* 对于全局变量对象和活动对象的了解
* 接触作用域，了解作用域链的执行机制
* 实例说明作用域链在JavaScript中对变量作用范围的控制
* 讲解一下闭包

## 关键词

* `EC`：执行上下文（`Execution Context`）
* `Scope`：作用域
* `Scope Chain`：作用域链
* `VO`：变量对象（`Variable Object`）
* `AO`：活动对象（`Activation Object`）
* `Closure`：闭包


## 变量和执行上下文

在引出变量对象概念之前，我们先做一个铺垫。编程的世界核心元素是什么？目前的我认为是数据结构和算法，当然这已经是一种相当抽象的说法，在JavaScript编程中，切实的说就是变量和函数。但是我们在日常编程过程中写的代码是没有任何意义的，只有在运行的时候，问题才能得到解决。那么运行的时候，变量和函数又何去何从？

我们知道在ECMAscript中变量是和上下文有密切关系的。
``` js
var a = 10; // 全局的变量

(function () {
  var b = 20; // function函数中的局部变量
})();

alert(a); // 10
alert(b); // 全局变量 "b" 没有声明
```

并且，很多程序员也都知道，当前ECMAScript规范指出独立作用域只能通过“函数(function)”代码类型的执行上下文创建。也就是说，相对于C/C++来说，ECMAScript里的for循环并不能创建一个局部的上下文。

```js
for (var k in {a: 1, b: 2}) {
  alert(k);
}
 
alert(k); // 尽管循环已经结束但变量k依然在当前作用域
```

如果变量与执行上下文相关，那变量自己应该知道它的数据存储在哪里，并且知道如何访问。这种机制称为变量对象(variable object)。

```
变量对象(缩写为VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：
    变量 (var, 变量声明);
    函数声明 (FunctionDeclaration, 缩写为FD);
    函数的形参
```

## 执行上下文（Execution Context）的组成

上文中我们引出了执行上下文的概念，在理解这个概念时可以把执行上下文可以抽象为一个简单的对象。每个上下文包含一系列属性(我们称之为 上下文状态(context’s state) ) 用以跟踪相关代码的执行过程。下图展示了上下文的结构：

![alt text](../_assets/20190527112822.png "JavaScript call stack ")

代码表示

```js
executionContext：{
    variable object：vars, functions, declaration, arguments...
    scope chain: variable object + all parents scopes
    thisValue: Context object
}
```

除了这3个所需要的属性(变量对象(variable object)， this指针(this value)， 作用域链(scope chain) )，执行上下文根据具体实现还可以具有任意额外属性。下面我们将对这些概念进行一一解析。

## 变量对象(variable object)

> Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the variable object. For function code, parameters are added as properties of the variable object.

> 译文：每一个执行上下文都会分配一个**变量对象(variable object)**，变量对象的属性由 **变量(variable)** 和 **函数声明(function declaration)** 构成。在函数上下文情况下， **参数列表(parameter list)** 也会被加入到变量对象(variable object)中作为属性。

变量对象不包含 函数表达式(function expressions) (与 函数声明(function declarations) 比较 )。
```js
var foo = 10;
 
function bar() { var a = 20 } // function declaration, FD
(function baz() {}); // function expression, FE
 
console.log(
  this.foo == foo, // true
  window.bar == bar // true
);
 
console.log(baz); // ReferenceError, "baz" is not defined
```
![alt text](../_assets/20190525181656.png "JavaScript call stack ")

### 分类

我们知道执行上下文有全局执行上下文，函数执行上下文。相应的变量对象也有Global object和Activation object。

可以适当的把变量对象看作是一个接口，Global object和Activation object实现了该接口，变量对象是对于执行上下文中准备执行的变量、函数声明的元素的结合的对象的一种抽象。

```
抽象变量对象VO (变量初始化过程的一般行为)
  ║
  ╠══> 全局上下文变量对象GlobalContextVO
  ║        (VO === this === global)
  ║
  ╚══> 函数上下文变量对象FunctionContextVO
           (VO === AO, 并且添加了<arguments>和<formal parameters>)
```

```js
var a = 10;
 
function test(x) {
  var b = 20;
};
 
test(30);
```

伪代码表示变量对象
``` js
// 全局上下文的变量对象
VO(globalContext) = {
  a: 10,
  test: <reference to function>
};

// test函数上下文的变量对象
VO(test functionContext) = {
  x: 30,
  b: 20
};

testEC = {
  VO: {
    a: 10,
    foo: <reference to function>
  },
  [[Scope]]: <reference to scope chain>,
  this: <reference to this binding>
}
```

## 全局对象（Global object）

首先，我们要给全局对象一个明确的定义：

全局对象(Global object) 是在进入任何执行上下文之前就已经创建了的对象；
这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。
全局对象初始创建阶段将Math、String、Date、parseInt作为自身属性，等属性初始化，同样也可以有额外创建的其它对象作为属性（其可以指向到全局对象自身）。例如，在DOM中，全局对象的window属性就可以引用全局对象自身(当然，并不是所有的具体实现都是这样)：

```js
global = {
  Math: <...>,
  String: <...>
  ...
  ...
  window: global //引用自身
};
```

当访问全局对象的属性时通常会忽略掉前缀，这是因为全局对象是不能通过名称直接访问的。不过我们依然可以通过全局上下文的this来访问全局对象，同样也可以递归引用自身。例如，DOM中的window。综上所述，代码可以简写为：

```js
String(10); // 就是global.String(10);
 
// 带有前缀
window.a = 10; // === global.window.a = 10 === global.a = 10;
this.b = 20; // global.b = 20;
```

因此，回到全局上下文中的变量对象——在这里，变量对象就是全局对象自己：

`VO(globalContext) === global;`

非常有必要要理解上述结论，基于这个原理，在全局上下文中声明的对应，我们才可以间接通过全局对象的属性来访问它（例如，事先不知道变量名称）。

```js
var a = new String('test');
 
alert(a); // 直接访问，在VO(globalContext)里找到："test"
 
alert(window['a']); // 间接通过global访问：global === VO(globalContext): "test"
alert(a === this.a); // true
 
var aKey = 'a';
alert(window[aKey]); // 间接通过动态属性名称访问："test"
```

## 活动对象(activation object)

> When control enters an execution context for function code, an object called the activation object is created and associated with the execution context. The activation object is initialised with a property with name arguments and attributes { DontDelete }. The initial value of this property is the arguments object described below.  
> The activation object is then used as the variable object for the purposes of variable instantiation.


> 译文：当函数被激活，那么一个活动对象(activation object)就会被创建并且分配给执行上下文。活动对象由特殊对象 arguments 初始化而成。随后，他被当做变量对象(variable object)用于变量初始化。

用代码来说明就是：
```js
function foo(x, y) {
  var z = 30;
  function bar() {} // FD
  (function baz() {}); // FE
}

foo(10, 20);
```

![alt text](../_assets/20190528122136.png "JavaScript call stack ")

## 执行环境和作用域链(execution context and scope chain)

### scope chain
作用域链，它在解释器进入到一个执行环境时初始化完成并将其分配给当前执行环境。每个执行环境的作用域链由当前环境的变量对象及父级环境的作用域链构成。
作用域链具体是如何构建起来的呢，先上代码：

```js
function test(num){
    var a = "2";
    return a+num;
}
test(1);
```
1. 执行流开始：初始化function test，test函数会维护一个私有属性 [[scope]],并使用当前环境的作用域链初始化，在这里就是 test.[[Scope]]=global scope.
2. test函数执行：这时候会为test函数创建一个执行环境，然后通过复制函数的[[Scope]]属性构建起test函数的作用域链。此时 test.scopeChain = [test.[[Scope]]]

test函数的活动对象被初始化，随后活动对象被当做变量对象用于初始化。即 test.variableObject = test.activationObject.contact[num,a] = [arguments].contact[num,a]

test函数的变量对象被压入其作用域链，此时 test.scopeChain = [ test.variableObject, test.[[scope]]];
至此test的作用域链构建完成。

## 作用域和作用域链

变量对象与当前作用域息息相关。不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。 

* [一道js面试题引发的思考][1]
* [EC+VO+SCOPE for ES3][2]
* [分不清的javascript运行机制 ][3]
* [JS 执行环境、作用域链、变量对象和活动对象的关系][4]
* [深入理解JavaScript系列（12）：变量对象（Variable Object）][5]
* [JavaScript作用域、上下文、执行期上下文、作用域链、闭包][6]
* [傻傻分不清的javascript运行机制][7]
* [JavaScript的核心原理][8]
* [V8 javascript 引擎][9]

[1]: https://github.com/kuitos/kuitos.github.io/issues/18
[2]: https://www.cnblogs.com/mininice/p/3876307.html
[3]: http://www.sohu.com/a/284117426_120045139
[4]: http://www.php.cn/js-tutorial-407137.html
[5]: http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html
[6]: https://blog.csdn.net/qq_27626333/article/details/78463565
[7]: https://www.jianshu.com/p/775d026862d3
[8]: https://blog.csdn.net/practicer2015/article/details/55803999
[9]: https://blog.csdn.net/practicer2015/article/details/55804206