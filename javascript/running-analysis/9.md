# JavaScript执行机制深度解析——EC和Scope、VO、AO（ES3规范）

## 前文回顾

在探讨JavaScript执行机制的时候，我们首先引入了event loop模型，从宏观上对于JavaScript运行机制有个**大概**的了解，然后针对该模型各个部分做了详细的拆分解析，由此引出了执行栈和执行上下文。我们大致知道执行上下文就是函数运行时的环境，这个环境如何具象化，我们还需要引出变量对象的概念，把它看做一个对象，这个对象存储着JavaScript函数运行的一切条件。这样就能更加具体对于变量、函数声明、作用域、作用域链进行更加详尽的阐述。

但在深入讨论之前，我还在[《JavaScript执行机制深度解析——执行上下文ES3规范和ES5规范》](https://github.com/Martin-Shao/Road-to-FullStack/blob/master/javascript/running-analysis/readme.md)一文中，对于讨论执行上下文划分了一个界限，以不同版本的实现标准为依据进行讨论。本文主要探讨的ES3版本的执行上下文实现机制，其中包含的主要内容有变量对象、活动对象、作用域、作用域链、闭包等

## 大纲

* 执行上下文的组成
* AO与VO
* 作用域和作用域链

## 关键词

* `EC`：执行上下文（`Execution Context`）
* `Scope`：作用域
* `Scope Chain`：作用域链
* `VO`：变量对象（`Variable Object`）
* `AO`：活动对象（`Activation Object`）
* `Closure`：闭包


## 变量和执行上下文

在讨论这个话题之前，在引出变量对象概念之前，我们先做一个铺垫。编程的世界核心元素是什么？目前的我认为是数据结构和算法，当然这已经是一种相当抽象的说法，在JavaScript编程中，切实的说就是变量和函数。但是我们在日常编程过程中写的代码是没有任何意义的，只有在运行的时候，问题才能得到解决。那么运行的时候，变量和函数又何去何从？

我们知道在ECMAscript中变量是和上下文有密切关系的。
``` js
var a = 10; // 全局上下文中的变量

(function () {
  var b = 20; // function上下文中的局部变量
})();

alert(a); // 10
alert(b); // 全局变量 "b" 没有声明
```

并且，很多程序员也都知道，当前ECMAScript规范指出独立作用域只能通过“函数(function)”代码类型的执行上下文创建。也就是说，相对于C/C++来说，ECMAScript里的for循环并不能创建一个局部的上下文。

```js
for (var k in {a: 1, b: 2}) {
  alert(k);
}
 
alert(k); // 尽管循环已经结束但变量k依然在当前作用域
```

如果变量与执行上下文相关，那变量自己应该知道它的数据存储在哪里，并且知道如何访问。这种机制称为变量对象(variable object)。

```
变量对象(缩写为VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：
    变量 (var, 变量声明);
    函数声明 (FunctionDeclaration, 缩写为FD);
    函数的形参
```

## 执行上下文（Execution Context）的组成

在event loop模型图中可以很直观看到，当JS引擎执行JavaScript代码执行的时候，会进入不同的执行环境(执行上下文)，这些执行环境会构成了一个执行环境栈(执行上下文栈)（Execution context stack，ECS）。

关于执行上下文和调用栈之间的关系，我们在《JavaScript执行机制深度解析——执行上下文与调用栈》一文中已经做出比较详情的解释，这里我们不再做深入探讨。

执行上下文可以抽象为一个简单的对象。每个上下文包含一系列属性(我们称之为 上下文状态(context’s state) ) 用以跟踪相关代码的执行过程。下图展示了上下文的结构：

![alt text](../_assets/20190527112822.png "JavaScript call stack ")

除了这3个所需要的属性(变量对象(variable object)， this指针(this value)， 作用域链(scope chain) )，执行上下文根据具体实现还可以具有任意额外属性。

## execution context
顾名思义 执行环境/执行上下文。在javascript中，执行环境可以抽象的理解为一个object，它由以下几个属性构成：

```js
executionContext：{
    variable object：vars,functions,arguments,
    scope chain: variable object + all parents scopes
    thisValue: context object
}
```

此外在js解释器运行阶段还会维护一个环境栈，当执行流进入一个函数时，函数的环境就会被压入环境栈，当函数执行完后会将其环境弹出，并将控制权返回前一个执行环境。环境栈的顶端始终是当前正在执行的环境！
通俗来讲，就是：当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：

进入执行上下文（当进入执行上下文时，这时候还没有执行代码）
代码执行  (在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值)

## 变量对象(variable object)

> Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the variable object. For function code, parameters are added as properties of the variable object.

> 译文：每一个执行上下文都会分配一个**变量对象(variable object)**，变量对象的属性由 **变量(variable)** 和 **函数声明(function declaration)** 构成。在函数上下文情况下， **参数列表(parameter list)** 也会被加入到变量对象(variable object)中作为属性。

变量对象不包含 函数表达式(function expressions) (与 函数声明(function declarations) 比较 )。
```js
var foo = 10;
 
function bar() { var a = 20 } // function declaration, FD
(function baz() {}); // function expression, FE
 
console.log(
  this.foo == foo, // true
  window.bar == bar // true
);
 
console.log(baz); // ReferenceError, "baz" is not defined
```
![alt text](../_assets/20190525181656.png "JavaScript call stack ")

### 分类

我们知道执行上下文有全局执行上下文，函数执行上下文。相应的变量对象也有Global object和Activation object。

可以适当的把变量对象看作是一个接口，Global object和Activation object实现了该接口，变量对象是对于执行上下文中准备执行的变量、函数声明的元素的结合的对象的一种抽象。

```
抽象变量对象VO (变量初始化过程的一般行为)
  ║
  ╠══> 全局上下文变量对象GlobalContextVO
  ║        (VO === this === global)
  ║
  ╚══> 函数上下文变量对象FunctionContextVO
           (VO === AO, 并且添加了<arguments>和<formal parameters>)
```

``` html
<script type="text/javascript">
var aa = 11;

function foo(b) {
  var a = 10;
  return a + b + aa;
}

function bar(x) {
  var y = 3;
  return foo(x * y);
}
console.log(bar(7));
</script>
```

``` js
// 全局上下文的变量对象
VO(globalContext) = {
  a: 10,
  test: <reference to function>
};

// test函数上下文的变量对象
VO(test functionContext) = {
  x: 30,
  b: 20
};

barEC = {
  VO: {
    a: 10,
    foo: <reference to function>
  },
  [[Scope]]: <reference to scope chain>,
  this: <reference to this binding>
}
```

## 活动对象(activation object)

> When control enters an execution context for function code, an object called the activation object is created and associated with the execution context. The activation object is initialised with a property with name arguments and attributes { DontDelete }. The initial value of this property is the arguments object described below.  
> The activation object is then used as the variable object for the purposes of variable instantiation.


> 译文：当函数被激活，那么一个活动对象(activation object)就会被创建并且分配给执行上下文。活动对象由特殊对象 arguments 初始化而成。随后，他被当做变量对象(variable object)用于变量初始化。

用代码来说明就是：

```js
function a(name, age){
    var gender = "male";
    function b(){}
}
a(“k”,10);
```


```js
function foo(x, y) {
  var z = 30;
  function bar() {} // FD
  (function baz() {}); // FE
}

foo(10, 20);
```

a被调用时，在a的执行上下文会创建一个活动对象AO，并且被初始化为 AO = [arguments]。随后AO又被当做变量对象(variable object)VO进行变量初始化,此时 VO = [arguments].concat([name,age,gender,b])。

发现有代码调用了一个函数
在执行这个function之前，创建一个执行上下文（execution context），也可以叫执行环境。
进入创建阶段（VO创建）
1. 初始化作用域链（scope chain）
2. 创建变量函数（variable object / VO）
3. 创建参数对象（arguments object，传进来的参数）,检查上下文，初始化其名字和值，以及建立引用对象的拷贝。
4. 扫描上下文中的函数声明
5. 为每一个扫描到的函数声明在VO中创建一个属性，命名为函数的名字，指向了存储空间中的对应函数。
6. 如果函数名称已经存在了，这个引用指针将被重写为新的这一个。
7. 扫描上下文中的变量声明
8. 为每一个扫描到的变量声明在VO中创建一个属性，命名为变量的名字，初始化值为undefined。
9. 如果变量名在内存中已经存在了，就跳过。
10. 决定上下文中this的指向。

执行阶段（VO => AO）
1. 执行/解释上下文中的function，为变量赋值
2. 代码按行执行

![alt text](../_assets/20190525183016.png "JavaScript call stack ")

## 执行环境和作用域链(execution context and scope chain)

### scope chain
作用域链，它在解释器进入到一个执行环境时初始化完成并将其分配给当前执行环境。每个执行环境的作用域链由当前环境的变量对象及父级环境的作用域链构成。
作用域链具体是如何构建起来的呢，先上代码：

```js
function test(num){
    var a = "2";
    return a+num;
}
test(1);
```
1. 执行流开始：初始化function test，test函数会维护一个私有属性 [[scope]],并使用当前环境的作用域链初始化，在这里就是 test.[[Scope]]=global scope.
2. test函数执行：这时候会为test函数创建一个执行环境，然后通过复制函数的[[Scope]]属性构建起test函数的作用域链。此时 test.scopeChain = [test.[[Scope]]]

test函数的活动对象被初始化，随后活动对象被当做变量对象用于初始化。即 test.variableObject = test.activationObject.contact[num,a] = [arguments].contact[num,a]

test函数的变量对象被压入其作用域链，此时 test.scopeChain = [ test.variableObject, test.[[scope]]];
至此test的作用域链构建完成。

## 作用域和作用域链

变量对象与当前作用域息息相关。不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。 



* [一道js面试题引发的思考][1]
* [EC+VO+SCOPE for ES3][2]
* [分不清的javascript运行机制 ][3]
* [JS 执行环境、作用域链、变量对象和活动对象的关系][4]
* [深入理解JavaScript系列（12）：变量对象（Variable Object）][5]
* [JavaScript作用域、上下文、执行期上下文、作用域链、闭包][6]
* [傻傻分不清的javascript运行机制][7]
* [JavaScript的核心原理][8]
* [V8 javascript 引擎][9]


[1]: https://github.com/kuitos/kuitos.github.io/issues/18
[2]: https://www.cnblogs.com/mininice/p/3876307.html
[3]: http://www.sohu.com/a/284117426_120045139
[4]: http://www.php.cn/js-tutorial-407137.html
[5]: http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html
[6]: https://blog.csdn.net/qq_27626333/article/details/78463565
[7]: https://www.jianshu.com/p/775d026862d3
[8]: https://blog.csdn.net/practicer2015/article/details/55803999
[9]: https://blog.csdn.net/practicer2015/article/details/55804206