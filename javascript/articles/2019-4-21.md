# JavaScript执行机制深度解析一：认识栈与堆

内存的生命周期：
1、分配所需的内存
2、内存的读与写
3、不需要时将其释放

堆内存、栈内存与调用栈
队列内存空间

堆内存：指的是堆这种数据结构（以下简称堆）实现的内存区域。  
栈内存：指的是栈这种数据结构（以下简称栈）实现的内存区域。

堆是无序的类似（key-value）这种方数据结构，类似书架，没有顺序和规范的入口出口。

栈LIFO，后进先出

程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种叫做栈（stack，或叫堆内存），另一种叫做堆（heap，或叫堆内存）。

heap是没有结构的，数据可以任意存放。heap用于复杂数据类型（引用类型）分配空间，例如数组对象、object对象。

stack是有结构的，每个区块按照一定次序存放（后进先出），stack中主要存放一些基本类型的变量和对象的引用，存在栈中的数据大小与生存期必须是确定的。可以明确知道每个区块的大小，因此，stack的寻址速度要快于heap。



所有语言的内存生命周期都基本一致，不同的是最后一步在低级语言中很清晰，但是在像JavaScript 等高级语言中，这一步是隐藏的、透明的。

 
js的内存生命周期：
1、定义变量时就完成了内存分配
2、使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。
3、而内存的释放而依赖GC机制（高级语言解释器嵌入的“垃圾回收器”）。

##堆（heap）与栈（stack）



程序运行时，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack是线程独占的，heap是线程共用的。此外，stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。所以这里只看stack的大小限制。下面是一个简单的测试：

JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

两种类型：

JavaScript中变量类型有两种：

1. 基础类型（Undefined, Null, Boolean, Number, String, Symbol）一共6种
2. 引用类型（Object)

1. ECMAScript变量包含两种不同类型的值：基本类型值、引用类型值；

2. 基本类型值：指的是保存在栈内存中的简单数据段；

3. 引用类型值：指的是那些保存在堆内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象；

两种访问方式：

4. 基本类型值：按值访问，操作的是他们实际保存的值；

5. 引用类型值：按引用访问，当查询时，我们需要先从栈中读取内存地址，然后再顺藤摸瓜地找到保存在堆内存中的值；


1、基本类型有Undefined、Null、Boolean、Number 和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。

2、引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。（自己加的：比如数组和对象）如下图所示：栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。 

3、栈内存：存放基本类型。 堆内存：存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象。）

4、基本类型在当前执行环境结束时销毁，而引用类型不会随执行环境结束而销毁，只有当所有引用它的变量不存在时这个对象才被垃圾回收机制回收。


调用栈和执行栈、内存栈