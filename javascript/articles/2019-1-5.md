# JavaScript深入之执行上下文栈和变量对象

首先给出几个重要的概念总结：
1. 执行上下文(Execution Context)定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
2. 每个执行上下文都有一个与之关联的变量对象(Variable Object)，上下文中定义的所有变量和函数都保存在这个对象中。
3. 全局上下文的变量对象初始化是全局对象，Web浏览器中，全局执行执行上下文被认为是window对象。
4. 函数上下文的变量对象激活后称为活动对象(Activation Object), 活动对象初始化只包括 Arguments 对象。
5. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
6. 在代码执行阶段，会再次修改变量对象的属性值。

在介绍JavaScript执行栈之前，首先明确几个概念：
* `EC`：函数执行环境（或执行上下文），Execution Context
* `ECS`：执行环境栈（执行栈），Execution Context Stack
* `VO`：变量对象，Variable Object
* `AO`：活动对象，Active Object
* `GO`：全局对象，Global Object
* `scope chain`：作用域链

执行上下文总共有三种类型

* **全局执行上下文**： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 `this` 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
* **函数执行上下文**： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。
* **Eval 函数执行上下文**： 运行在 `eval` 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 `eval` 函数，所以在这里不再讨论。

函数上下文
在函数上下文中，用活动对象(activation object, AO)来表示变量对象。

活动对象和变量对象的区别在于

1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。
2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。
调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。

执行过程
执行上下文的代码会分成两个阶段进行处理

1、进入执行上下文

2、代码执行

进入执行上下文
很明显，这个时候还没有执行代码

此时的变量对象会包括（如下顺序初始化）：

1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。
2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。
3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。
上代码就直观了

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;
}

foo(1);
```

对于上面的代码，这个时候的AO是

```js
AO = {
  arguments: {
    0: 1,
    length: 1
  },
  a: 1,
  b: undefined,
  c: reference to function c(){},
  d: undefined
}
```

形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值

代码执行
这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下

```js
AO = {
  arguments: {
    0: 1,
    length: 1
  },
  a: 1,
  b: 3,
  c: reference to function c(){},
  d: reference to FunctionExpression "d"
}
```
