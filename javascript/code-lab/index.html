<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"></script>
  <!-- <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"></script> -->
  <script src="https://cdn.jsdelivr.net/npm/ramda@0.27.1/dist/ramda.min.js"></script>
</head>

<body>
  <button onclick="handleTestClick()">测试</button>
  <script>
    console.info(moment.unix(1578585600 + 86399).format('YYYY-MM-DD HH:mm:ss'))
    // let links = [
    //   {
    //     region: "cn-shanghai",
    //     link: {
    //       access: 'link-cn-shanghai-access',
    //       gpu: 'link-cn-shanghai-gpu',
    //     }
    //   },
    //   {
    //     region: "cn-hangzhou",
    //     link: {
    //       access: 'link-cn-hangzhou-access',
    //       gpu: 'link-cn-hangzhou-gpu',
    //     }
    //   },
    // ]
    // const fromPairs = pairs => pairs.reduce(
    //   (res, pair) => (
    //     (res[pair['region']] = pair['link']), res), {}
    // )
    // const regionLink = fromPairs(links)
    // const regions = links.map(
    //   item => item.region
    // )
    // const linkList = []
    // regions.forEach(region => {
    //   let regionss = regionLink[region]
    //   let keys = Object.keys(regionss)
    //   keys.forEach(key => {
    //     linkList.push({
    //       [`${region}-${key}`]: regionLink[region][key]
    //     })
    //   })
    // })
    // console.info(regionLink, regions, linkList)
    // const debounceTest = () =>
    //   _.debounce(() => {
    //     console.info('test---')
    //   }, 1000, {
    //     'leading': true,
    //     'trailing': false
    //   })
    // function handleTestClick() {
    //   console.info('---', debounceTest)
    //   debounceTest()
    // }

    // const todayYear = (new Date()).getFullYear();
    // const todayMonth = (new Date()).getMonth();
    // const todayDay = (new Date()).getDate();
    // const todayTime = (new Date(todayYear, todayMonth, todayDay, '00', '00', '00')).getTime();//毫秒
    // let day = moment(todayTime);
    // let lastWeek = moment().add(-2, 'y');
    // console.info(lastWeek.unix())
    // console.info(day.format('YYYY-MM-DD HH:mm:ss'))
    // console.info(lastWeek.format('YYYY-MM-DD HH:mm:ss'))
    // const tradeCreatedStart = new Date(moment().format('YYYY-MM-DD 00:00:00')).getTime();
    // const tradeCreatedEnd = new Date(moment().format('YYYY-MM-DD 23:59:59')).getTime();

    // function ten2twelve(x) {
    //   var r = ''
    //   var mod = 0
    //   r = parseInt(x / 12)
    //   mod = x % 12
    //   console.info('ten2twelve...', r, mod)
    //   if (mod === 0) return `${parseInt(r) - 1}-12`
    //   else return `${parseInt(r)}-${mod}`
    // }

    // function midTime(startTime, endTime) {
    //   let midDate = []
    //   let startDate = new Date(startTime)
    //   let endDate = new Date(endTime)
    //   console.info(moment(startDate).format('YYYY-MM-DD HH:mm:ss'))
    //   console.info(moment(endDate).format('YYYY-MM-DD HH:mm:ss'))
    //   let startTWDate = parseInt(startDate.getFullYear() * 12) + startDate.getMonth()
    //   let endTWDate = parseInt(endDate.getFullYear() * 12) + endDate.getMonth()
    //   console.info(startTWDate, endTWDate)
    //   while (startTWDate < endTWDate) {
    //     startTWDate++
    //     console.info(startTWDate)
    //     midDate.push(startTWDate)
    //   }
    //   let carry = false
    //   const midDateStr = midDate.map(item => {
    //     var r = 0
    //     var mod = 0
    //     var midss = ''
    //     r = parseInt(item / 12)
    //     mod = item % 12
    //     if(mod === 0 ) carry = !carry
    //     if (carry) midss = `${parseInt(r) - 1}-${mod-1}`
    //     else midss = `${parseInt(r)}-${mod+1}`
    //     if(mod === 11 ) carry = !carry
    //     return midss
    //   })
    //   console.info(midDate)
    //   console.info(midDateStr)
    // }

    // midTime(lastWeek.unix() * 1000, day.unix() * 1000)

    // const customer = [
    //   {
    //     vip: 'sss',
    //     id: '0001',
    //     name: '邵孤城',
    //     surplus: 1000
    //   },
    //   {
    //     vip: 'ss',
    //     id: '0001',
    //     name: '邵孤城',
    //     surplus: 1000
    //   },
    //   {
    //     vip: 's',
    //     id: '0001',
    //     name: '邵孤城',
    //     surplus: 1000
    //   },
    //   {
    //     vip: 'p',
    //     id: '0001',
    //     name: '邵孤城',
    //     surplus: 1000
    //   },
    //   {
    //     vip: 'p',
    //     id: '0001',
    //     name: '邵孤城',
    //     surplus: 1000
    //   },
    // ]

    // function membershipLevelIdentify(value) {
    //   return new Map([
    //     ['sss', () => { return '超级24K纯金土豪' }],
    //     ['ss', () => { return '超级土豪' }],
    //     ['s', () => { return '小土豪' }],
    //     ['p', () => { return '穷逼' }],
    //   ]).get(value)
    // }

    // customer.map(item => {
    //   const resultFn = membershipLevelIdentify(item.vip)
    //   console.info(resultFn())
    // })

    // const membershipLevelIdentify = _.cond([
    //   [_.matches({ 'vip': 'sss' }), _.constant('超级24K纯金土豪')],
    //   [_.matches({ 'vip': 'ss' }), _.constant('超级土豪')],
    //   [_.matches({ 'vip': 's' }), _.constant('小土豪')],
    //   [_.matches({ 'vip': 'p' }), _.constant('穷逼')],
    //   [_.stubTrue, _.constant('黑户')]
    // ]);

    // customer.map(item => {
    //   console.info(membershipLevelIdentify(item))
    // })

    // function changeCode(val) {
    //   let char0 = val.charAt(0)
    //   let char1 = val.charAt(1)
    //   let char2 = val.charAt(2)
    //   if (char2.charCodeAt(0) >= 122) {
    //     if (char1.charCodeAt(0) >= 122) {
    //       if (char0.charCodeAt(0) >= 122) {
    //         console.info("The max code is zzz, no other max code now.")
    //       } else {
    //         char2 = String.fromCharCode(97)
    //         char1 = String.fromCharCode(97)
    //         char0 = String.fromCharCode(char0.charCodeAt(0) + 1)
    //       }
    //     } else {
    //       char2 = String.fromCharCode(97)
    //       char1 = String.fromCharCode(char1.charCodeAt(0) + 1)
    //     }
    //   } else {
    //     char2 = String.fromCharCode(char2.charCodeAt(0) + 1)
    //   }
    //   return char0 + char1 + char2
    // }

    // function charStep(char) {
    //   return String.fromCharCode(char.charCodeAt(0) + 1)
    // }

    // function backStart() {
    //   return String.fromCharCode(97)
    // }

    // function charLimit(char, limit) {
    //   return char.charCodeAt(0) >= limit
    // }

    // function encode(str) {
    //   const [char0, char1, char2] = str
    //   console.info(char0, char1, char2)
    //   const charArr = [char0, char1, char2]
    //   // return charArr.map(
    //   //   char => charLimit(char, 122) ? backStart() : charStep(char)
    //   // ).join('')
    //   return charArr.reduce(
    //     (acc, char) => acc + (charLimit(char, 122) ? backStart() : charStep(char))
    //     , ''
    //   )
    // }

    // console.info(encode('abc'))

    // const func = _.cond([
    //   [_.matches({ 'a': 1 }), _.constant('matches A')],
    //   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
    //   [_.stubTrue, _.constant('no match')]
    // ]);

    // const aCond = func({ 'a': 1, 'b': 2 });
    // // => 'matches A'

    // const bCond = func({ 'a': 0, 'b': 1 });
    // // => 'matches B'

    // const cCond = func({ 'a': '1', 'b': '2' });
    // // => 'no match'

    // console.info(aCond, bCond, cCond)

    // var objects = _.times(2, _.constant({ 'a': 1 }));

    // console.log(objects);
    // // => [{ 'a': 1 }, { 'a': 1 }]

    // console.log(objects[0] === objects[1]);
    // // => true

    // _.times(3, String);
    // // => ['0', '1', '2']

    // _.times(4, _.constant(0));
    // // => [0, 0, 0, 0]


    // const curry = _.curry

    // const match = curry(function (what, str) {
    //   return str.match(what)
    // })

    // const replace = curry(function (what, replacement, str) {
    //   return str.replace(what, replacement)
    // })

    // const filter = curry(function (f, ary) {
    //   return ary, filter(f)
    // })

    // const map = curry(function (f, ary) {
    //   return ary.map(f)
    // })

    // match(/\s+/g, "hello world"); // [ ' ' ]
    // match(/\s+/g)("hello world"); // [ ' ' ]

    // const hasSpaces = match(/\s+/g)
    // hasSpaces("hello world") // [ ' ' ]

    // filter(hasSpaces, ['tori_spelling', 'tori amos']) // ["tori amos"]

    // const findSpaces = filter(hasSpaces)
    // findSpaces(['tori_spelling', 'tori amos']) // ["tori amos"]

    // const noVowels = replace(/[aeiou]/ig)
    // const censored = noVowels('*')

    // censored('Chocolate Rain')


    // const getChildren = function (x) {
    //   return x.childNodes
    // }

    // const allTheChildren = map(getChildren)

    // const allTheChildren = function (elements) {
    //   return _.map(elements, getChildren)
    // }

    const compose = (f, g) => x => f(g(x))

    const toUpperCase = x => x.toUpperCase()

    const exclaim = x => x + '!'

    const shout = compose(exclaim, toUpperCase)

    // const shout = x => exclaim(toUpperCase(x))

    console.info(shout('send in the clowns'))

    const head = x => x[0]

    const reverse = R.reduce((acc, x) => [x].concat(acc), [])

    const last = compose(head, reverse)

    console.info(last(['jumpkick', 'roundhouse', 'uppercut']))

    // 结合律（associativity）
    // const associative = compose(f, compose(g, h)) == compose(compose(f, g), h);

    const lastUpper = R.compose(toUpperCase, head, reverse);

    const loudLastUpper = R.compose(exclaim, toUpperCase, head, reverse)

    console.info(lastUpper(['jumpkick', 'roundhouse', 'uppercut']))
    console.info(loudLastUpper(['jumpkick', 'roundhouse', 'uppercut']))
  </script>
</body>

</html>